 #pragma config(Sensor, port8,  gyro,           sensorVexIQ_Gyro)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor2,          hang1,         tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor3,          intake,        tmotorNone, openLoop)
#pragma config(Motor,  motor4,          catapult1,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDC ontrol, reversed, driveRight, encoder)
#pragma config(Motor,  motor10,         catapult,      tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define INERTIA_DIE_DOWN 300

float dt = 25;

float iChC_filtered = 0.0;

float iChA_filtered = 0.0;
float desired_heading = 0.0;

bool drive_override = false;


#define GYRO_SAMPLING_SECONDS 5
#define ACCEPTABLE_DRIFT_RANGE 0.05
float GyroDriftRate;

#define COUNT_PER_ROUND 960
#define WHEEL_TRAVEL 20
#define GEAR_RATIO 2.5
#define RATE 1

int iStrafeMapping[101] = {
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,
	20,20,20,20,20,20,20,20,20,20,
	20,20,20,20,20,20,20,20,20,20,
	30,30,30,30,30,30,30,30,30,30,
	30,30,30,30,30,30,30,30,30,30,
	40,40,40,40,40,60,60,60,60,60,
	60,60,60,80,80,95,95,95,95,95,95}; // Max not to 100 to allow room for PID.

int iTurnMapping[101] = {
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,
	20,20,20,20,20,20,20,20,20,20,
	20,20,20,20,20,20,20,20,20,20,
	30,30,30,30,30,30,30,30,30,30,
	30,30,30,30,30,30,30,30,30,30,
	30,30,30,30,30,30,30,30,30,30,
	40,40,40,40,40,40,40,60,60,60,80};

float cmToEncoderUnit(float distance)
{
	return distance * COUNT_PER_ROUND / WHEEL_TRAVEL / GEAR_RATIO / RATE;
}

//47 to 56 creates a new type of struct and names it structPID
typedef struct {
	float setpoint;
	float measured_value;
	float integral;
	float prev_error;
	float kp;
	float ki;
	float kd;
	float delta;
}structPID;

structPID pidOrientation;




void setGyroStable()
{
	GyroDriftRate = 100;

	while (GyroDriftRate > ACCEPTABLE_DRIFT_RANGE)
	{
		// Let the LED flashing to remind people do not move the robot.

		wait1Msec(2000);

		resetGyro(gyro);
		clearTimer(T4);
		wait1Msec(GYRO_SAMPLING_SECONDS*1000);

		GyroDriftRate = getGyroDegreesFloat(gyro) / GYRO_SAMPLING_SECONDS;

	}

}

float getGyroStable()
{
	return getGyroDegreesFloat(gyro) - GyroDriftRate * time1[T4] / 1000;
}

void resetGyroStable()
{
	resetGyro(gyro);
	clearTimer(T4);
}



float PIDControl (structPID &pid)
{
	float error = pid.setpoint - pid.measured_value;

	if ( abs(error) < pid.delta )
		error = 0;

	pid.integral = pid.integral + error * dt;
	float derivative = ( error - pid.prev_error ) / dt;
	float output = pid.kp * error + pid.ki * pid.integral + pid.kd * derivative;
	pid.prev_error = error;

	return output;
}



void initialize()
{
	setMotorEncoderUnits(encoderCounts);

	setMotorBrakeMode(rightMotor, motorCoast);
	setMotorBrakeMode(leftMotor, motorCoast);



	setMotorBrakeMode(rightMotor, motorHold);
	setMotorBrakeMode(leftMotor, motorHold);
}
/*
void LEDBusiness(int colour, int blinkTimeOn, int blinkTimeOff, int blinkColour, int blink)
{

timeStamp = time1[T1];
displayCenteredTextLine( 3, "%f", timeStamp );

if (blink == 0)
{
setTouchLEDColor(LED, colour);
waitUntil( getTouchLEDValue(LED) == 1 );
}
else if (blink ==1)
{
setTouchLEDColor(LED,colour);
waitUntil(getTouchLEDValue(LED) == 1);
setTouchLEDColor(LED,blinkColour);
setTouchLEDBlinkTime(LED, blinkTimeOn, blinkTimeOff);
}

wait(0.3);
resetGyro(Gyro);
targetHeading = 0;
}*/


task main()
{


while (true)
	{
		if ( abs(getJoystickValue(ChC)) > 5 )
		{
			clearTimer(T2);
		}

		if ( getTimerValue(T2) > INERTIA_DIE_DOWN || drive_override )
		{
			pidOrientation.measured_value = getGyroStable();
			pidOrientation.setpoint = desired_heading;

			iChC_filtered = -PIDControl(pidOrientation);
		}
		else
		{
			desired_heading = getGyroStable();
		}
		iChA_filtered=iStrafeMapping[abs(getJoystickValue(ChA))]*sgn(getJoystickValue(ChA));
		iChC_filtered=iTurnMapping[abs(getJoystickValue(ChC))]*sgn(getJoystickValue(ChC));
		pidOrientation.measured_value = getGyroStable();
		pidOrientation.setpoint = desired_heading;

		writeDebugStreamLine( "%f %f %f %f %f %f %f %f", getTimerValue(T2), iChA_filtered, iChC_filtered, getGyroDegrees(gyro), getGyroStable(), desired_heading );
		if(! drive_override)
		{
			setMotorSpeed(leftMotor,(iChA_filtered+iChC_filtered)/1);
			setMotorSpeed(rightMotor,(iChA_filtered-iChC_filtered)/1);
		}
		wait1Msec(dt);




	if (getJoystickValue(BtnRUp) == 1)
	{
		setMotorSpeed(catapult,100);
		setMotorSpeed(catapult1,100);
	}
	else if (getJoystickValue(BtnRDown) == 1)
	{
		setMotorSpeed(catapult,-100);
		setMotorSpeed(catapult1,-100);
	}
	else
	{
		setMotorSpeed(catapult,0);
	}




	if (getJoystickValue(BtnLUp) == 1)
	{
		setMotorSpeed(intake,100);
	}
	else if (getJoystickValue(BtnLDown) == 1)
	{
		setMotorSpeed(intake,-100);
	}
	else
	{
		setMotorSpeed(intake,0);
	}



	if (getJoystickValue(BtnFUp) == 1)
	{
		setMotorSpeed(hang1,100);
	}
	else if (getJoystickValue(BtnFDown) == 1)
	{
		setMotorSpeed(hang1,-100);
	}
	else
	{
		setMotorSpeed(hang1,0);
	}
}
}
