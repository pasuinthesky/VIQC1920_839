#pragma config(Sensor, port4,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port8,  LED,            sensorVexIQ_LED)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor7,          clawMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         tailMotor,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor12,         armMotor,      tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RATE 1.05
#define WAIT_CYCLE 20
#define MIN_SPEED 30
#define COUNT_PER_ROUND 960
#define GEAR_RATIO 1.5
#define DECEL_RATE 0.75
#define WHEEL_TRAVEL 20.0


#define ARM_SPEED 100
#define TAIL_SPEED 60
#define CLAW_SPEED 100

#define CLAW_OPEN -120
#define CLAW_CLOSE -450
#define CLAW_DELTA 65

#define TAIL_UP 2000
#define TAIL_DOWN 960
#define TAIL_DELTA 65

#define ARM_DELTA 65
#define MS_PER_ENCODER_UNIT 1


int currentCount, pickUpTrigger, targetHeading, cubeLevel;
int iArmLv[4] = {105, 400, 1100, 1455};

int tailTarget;

void Initialize()
// Prepare robot
{
	wait(1);
	resetGyro(Gyro);

	clearTimer(T1);

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorBrakeMode(leftMotor, motorHold);
	setMotorBrakeMode(rightMotor, motorHold);

}

float cmToEncoderUnit(float distance)
{
	return distance * COUNT_PER_ROUND / WHEEL_TRAVEL / GEAR_RATIO / RATE;
}

void goStraightDecel(int distance, int maxSpeed, float Ki, float Kp, int slowZonePercent)
//For no load: Ki = 0.0026, Kp = 0.5
{
	float motorSpeed;
	float error = 0, integral = 0, output;
	int targetCount = cmToEncoderUnit(distance);
	float slowZone = targetCount * slowZonePercent / 100;

	writeDebugStreamLine("targetCount = %d", targetCount);
	writeDebugStreamLine("slowZone = %d", slowZone);

	currentCount = 0;
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	while ( currentCount < targetCount )
	{
		error = getGyroDegreesFloat(Gyro) - targetHeading;
		integral = integral + error;
		output = error * Kp + integral * Ki;

    if ( currentCount < ( targetCount - slowZone ) )
		{
			motorSpeed = maxSpeed;
		}
		else
		{
			motorSpeed = sgn(maxSpeed) * MIN_SPEED + DECEL_RATE * ( maxSpeed - sgn(maxSpeed) * MIN_SPEED ) * ( targetCount - currentCount ) / slowZone;
		}

		setMotorSpeed(leftMotor, motorSpeed + output);
		setMotorSpeed(rightMotor, motorSpeed - output);

		currentCount = abs( getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor) ) / 2;
//		writeDebugStreamLine("%d:  %f,  %f,  %f,  %f,  %f", time1[T1], error, integral, output, motorSpeed, currentCount);
//		writeDebugStreamLine("%d: error %d, integral %d, output %d, motorSpeed %d, currentCount %d", time1[T1], error, integral, output, motorSpeed, currentCount);
		displayCenteredBigTextLine(3, "%d, %d", currentCount, targetCount);
		wait1Msec(WAIT_CYCLE);
	}
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 0);
}

task moveTail()
{
	setMotorTarget( tailMotor, tailTarget, 100 );
	wait1Msec( abs( TAIL_UP - TAIL_DOWN ) * MS_PER_ENCODER_UNIT );
	EndTimeSlice();
}

void clawAction(int clawTarget)
{
	setMotorTarget( clawMotor, clawTarget, 100 );
	wait1Msec( abs( CLAW_CLOSE - CLAW_OPEN ) * MS_PER_ENCODER_UNIT );
	setMotorSpeed( clawMotor, 0 );
}

task returnArm()
{
	setMotorTarget(armMotor,iArmLv[0],100);
	wait1Msec( abs( getMotorEncoder(armMotor) - iArmLv[0] ) * MS_PER_ENCODER_UNIT );
	EndTimeSlice();
}

void drop()
{
	clawAction( CLAW_OPEN );
	if ( getMotorEncoder(armMotor) > ( iArmLv[2] - ARM_DELTA ) )
	{
		// This block should had been done by goStraightDecel function instead.
		setMotorSpeed(leftMotor,-100);
		setMotorSpeed(rightMotor,-100);
		wait1Msec(400);
		setMotorSpeed(leftMotor,0);
		setMotorSpeed(rightMotor,0);
	}
	startTask(returnArm);
}

task pick_up_cube()
{
	writeDebugStreamLine( "%f: %f, %f", time1[T1], currentCount, cmToEncoderUnit( pickUpTrigger ) );
	while ( currentCount < cmToEncoderUnit( pickUpTrigger ) )
		{
			writeDebugStreamLine( "%f: %f, %f", time1[T1], currentCount, cmToEncoderUnit( pickUpTrigger ) );
			wait1Msec( WAIT_CYCLE );
	}

	clawAction( CLAW_CLOSE );
	setMotorTarget( armMotor, iArmLv[cubeLevel], 100 );
	wait1Msec( abs( iArmLv[cubeLevel] - getMotorEncoder( armMotor ) ) * MS_PER_ENCODER_UNIT );
	setMotorSpeed( armMotor, 0 );
	EndTimeSlice();
}

void turnDecel(int inputHeading, float Ki, float Kp, int baseSpeed, int delta)
{
	float error = 0, integral = 0, output;

	targetHeading = inputHeading;

	while ( abs( getGyroDegreesFloat(Gyro) - targetHeading ) > delta )
	{
		error = getGyroDegreesFloat(Gyro) - targetHeading;
		integral = integral + error;
		output = error * Kp + integral * Ki;

		setMotorSpeed(leftMotor, sgn(error) * baseSpeed + output);
		setMotorSpeed(rightMotor, -sgn(error) * baseSpeed - output);

		//writeDebugStreamLine("%d:  %d,  %d,  %d", time1[T1], error, integral, output);
		wait1Msec(WAIT_CYCLE);
	}
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 0);
}
// 5, wait 2 secs, 25( reduce motor speed ), 30, grab, turn slighjtly less than 90
void GreencubeHigh()
{
	goStraightDecel(54, 90, 0.0026, 0.5, 20);
	turnDecel( 90, 0, 0.6, 5,  2);

	goStraightDecel(5, 100, 0.0026, 0.5, 5);
	wait( 2 );

	goStraightDecel(25, 60, 0.0026, 0.5, 40);

	//goStraightDecel(5, 30, 0.0026, 0.5, 40);


	pickUpTrigger = 4; cubeLevel = 3;
	startTask(pick_up_cube);
	goStraightDecel(10, 30, 0.003, 0.5, 30);

	turnDecel(180, 0, 0.45, 5, 2);
	wait( 1.5 );
/*
	while (true)
		displayCenteredBigTextLine( 3, "%d, %d", getGyroDegrees(Gyro), targetHeading );
*/

	goStraightDecel(20, 90, 0.003, 0.5, 40);
	goStraightDecel(7, 30, 0.003, 0.5, 0);
	drop();

}

void greenCubeLow()
{
	goStraightDecel(18, 90, 0.0026, 0.5, 20);

	pickUpTrigger = 3; cubeLevel = 2;
	startTask( pick_up_cube );
	goStraightDecel(20, 30, 0.0026, 0.5, 0);

	goStraightDecel(28, 60, 0.003, 0.6, 30);

	//goStraightDecel(43, 90, 0.003, 0.6, 40);
	drop();

	goStraightDecel(50, -70, 0.0026, 0.5, 15);
}

void LEDBusiness(int colour, int blinkTimeOn, int blinkTimeOff, int blinkColour, int blink)
{
 if (blink == 0)
	{
		setTouchLEDColor(LED, colour);
		waitUntil( getTouchLEDValue(LED) == 1 );
	}
	else if (blink ==1)
	{
		setTouchLEDColor(LED,colour);
		waitUntil(getTouchLEDValue(LED) == 1);
		setTouchLEDColor(LED,blinkColour);
		setTouchLEDBlinkTime(LED, blinkTimeOn, blinkTimeOff);
	}

	wait(0.3);
	resetGyro(Gyro);
}

void blueCube_NOT_DONE_YET()
{
	goStraightDecel(48, 90, 0.0026, 0.5, 20);
	turnDecel( -135, 0, 0.6, 5, 2 );

	currentCount = 0;
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	pickUpTrigger = 23; cubeLevel = 3;
	startTask( pick_up_cube );
	goStraightDecel(25, 40, 0.0026, 0.5, 0);

	turnDecel( -190, 0, 0.3, 5, 2 );

	goStraightDecel(42, -90, 0.0026, 0.5, 20);

	tailTarget = TAIL_UP;
	startTask( moveTail );
	turnDecel( -250, 0, 0.3, 5, 2 );
	goStraightDecel(200, 100, 0.003, 0.6, 20);
}

void reset()
{
	setMotorTarget(clawMotor, CLAW_OPEN, 100);
	setMotorTarget(tailMotor, TAIL_DOWN, 100);
	setMotorTarget(armMotor, iArmLv[0], 100);
	wait(0.7);
}

task main()
{
	setMotorEncoderUnits(encoderCounts);

	setMotorSpeed(clawMotor, 100);
	setMotorSpeed(tailMotor, -100);
	setMotorSpeed(armMotor, -100);
	wait(2);
	resetMotorEncoder(clawMotor);
	resetMotorEncoder(tailMotor);
	resetMotorEncoder(armMotor);

	reset();

	Initialize();
	targetHeading = 0;

	//goStraightDecel(100, 90, 0.0026, 0.5, 40);
	LEDBusiness(colorGreen, 0, 0, 0, 0);
	greenCubeLow();

	LEDBusiness(colorBlue, 0, 0, 0, 0);
	greenCubeLow();
	LEDBusiness(colorViolet, 0, 0, 0, 0);
	GreencubeHigh();
	//blueCube_NOT_DONE_YET();

}
