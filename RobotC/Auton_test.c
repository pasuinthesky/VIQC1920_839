#pragma config(Sensor, port4,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port8,  LED,            sensorVexIQ_LED)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor7,          clawMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         tailMotor,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor12,         armMotor,      tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RATE 1.04
#define WAIT_CYCLE 20
#define MIN_SPEED 20
#define COUNT_PER_ROUND 960
#define GEAR_RATIO 1.5
#define DECEL_RATE 0.75
#define SLOW_ZONE_PERCENT 40
#define WHEEL_TRAVEL 20.0


#define ARM_SPEED 100
#define TAIL_SPEED 60
#define CLAW_SPEED 100

#define CLAW_OPEN -120
#define CLAW_CLOSE -450
#define CLAW_DELTA 65

#define TAIL_UP 2000
#define TAIL_DOWN 960
#define TAIL_DELTA 65

#define ARM_DELTA 65
#define MS_PER_ENCODER_COUNT 1
#define MS_PER_ENCODER_DEGREE 2.5


int currentCount = 0;
float robotSpeed = 0;
float Ki = 0, Kp = 0;
int iArmLv[4] = {105, 400, 1050, 1455};

int tailTarget;
bool tailMoving = false, armMoving = false, pauseDriveTrain = false;

void Initialize()
// Prepare robot
{
	wait(1);
	clearTimer(T1);
	resetGyro(Gyro);

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

}

float cmToEncoderUnit(float distance)
{
	return distance * COUNT_PER_ROUND / WHEEL_TRAVEL / GEAR_RATIO / RATE;
}

task Steering()
//For no load: Ki = 0.0026, Kp = 0.5
{
	float error = 0, integral = 0, output;

	while ( true )
	{
		error = getGyroDegreesFloat(Gyro) - 0;
		integral = integral + error;
		output = error * Kp + integral * Ki;

		if ( ! pauseDriveTrain )
		{
			setMotorSpeed(leftMotor, robotSpeed + output);
			setMotorSpeed(rightMotor, robotSpeed - output);
			displayCenteredBigTextLine(3, "%d, %d, %d", robotSpeed, output, currentCount);
		}

		wait1Msec( WAIT_CYCLE );
	}
}

void pickup()
{
	armMoving = true;
	setMotorTarget( clawMotor, CLAW_CLOSE, 100 );
	wait1Msec( abs( CLAW_CLOSE - CLAW_OPEN ) * MS_PER_ENCODER_COUNT );
	setMotorSpeed( clawMotor, 0 );
	setMotorTarget( armMotor, iArmLv[1], 100 );
	wait1Msec( abs( iArmLv[1] - getMotorEncoder( armMotor ) ) * MS_PER_ENCODER_COUNT );
	setMotorSpeed( armMotor, 0 );
	armMoving = false;
}


void returnArm()
{
	setMotorTarget(armMotor,iArmLv[0],100);
	wait1Msec( abs( getMotorEncoder(armMotor) - iArmLv[0] ) * MS_PER_ENCODER_COUNT );
}

task taskReturnArm()
{
	armMoving = true;
	returnArm();
	armMoving = false;
	EndTimeSlice();
}

void drop()
{
	setMotorTarget( clawMotor, CLAW_OPEN, 100 );
	wait1Msec( abs( CLAW_CLOSE - CLAW_OPEN ) * MS_PER_ENCODER_COUNT );
	setMotorSpeed( clawMotor, 0 );
	wait1Msec(500);
	if ( getMotorEncoder(armMotor) > ( iArmLv[2] - ARM_DELTA ) )
	{
		pauseDriveTrain = false;
		robotSpeed = -60;
		Ki = 0.0026;
		Kp = 0.5;
		while ( currentCount > cmToEncoderUnit(50) )
		{
			wait1Msec( WAIT_CYCLE );
			currentCount = ( getMotorEncoder( leftMotor ) + getMotorEncoder ( rightMotor ) ) / 2;
		}
		pauseDriveTrain = true;
		setMotorSpeed( leftMotor, 0 );
		setMotorSpeed( rightMotor, 0 );
	}

	returnArm();
}

task pick_up_low_green()
{
	while ( currentCount < cmToEncoderUnit( 21 ) )
//		writeDebugStreamLine( "%f: %f, %f", time1[T1], currentCount, cmToEncoderUnit( 20.5 ) );
		wait1Msec( WAIT_CYCLE );

	pickup();
	setMotorTarget( armMotor, iArmLv[2], 100 );
	wait1Msec( abs( iArmLv[2] - getMotorEncoder( armMotor ) ) * MS_PER_ENCODER_COUNT );
	EndTimeSlice();
}

task main()
{
	setMotorEncoderUnits(encoderCounts);

	setMotorSpeed(clawMotor, 100);
	setMotorSpeed(tailMotor, -100);
	setMotorSpeed(armMotor, -100);
	wait(2);
	resetMotorEncoder(clawMotor);
	resetMotorEncoder(tailMotor);
	resetMotorEncoder(armMotor);

	setMotorTarget(clawMotor, CLAW_OPEN, 100);
	setMotorTarget(tailMotor, TAIL_DOWN, 100);
	setMotorTarget(armMotor, iArmLv[0], 100);
	wait(0.7);

	Initialize();

	//setMotorBrakeMode(leftMotor, motorCoast);
	//setMotorBrakeMode(rightMotor, motorCoast);

	int i = 0;

	startTask( Steering );

	robotSpeed = 90;
	Ki = 0.0026;
	Kp = 0.5;
	while ( currentCount < cmToEncoderUnit(18) )
	{
		wait1Msec( WAIT_CYCLE );
		currentCount = ( getMotorEncoder( leftMotor ) + getMotorEncoder ( rightMotor ) ) / 2;
	}

	startTask( pick_up_low_green );
	robotSpeed = 30;
	while ( currentCount < cmToEncoderUnit(40) )
	{
		wait1Msec( WAIT_CYCLE );
		currentCount = ( getMotorEncoder( leftMotor ) + getMotorEncoder ( rightMotor ) ) / 2;
/*
		i = i + 1;
		if ( i == 10 )
		{
			i = 0;
			writeDebugStreamLine( "%f: %d, %f, %f, %f", time1[T1], robotSpeed, Ki, Kp, currentCount );
		}
*/
	}

	robotSpeed = 90;
	Ki = 0.003;
	Kp = 0.006;
	while ( currentCount < cmToEncoderUnit(60) )
	{
		currentCount = ( getMotorEncoder( leftMotor ) + getMotorEncoder ( rightMotor ) ) / 2;
		wait1Msec( WAIT_CYCLE );
	}

	robotSpeed = 30;
	while ( currentCount < cmToEncoderUnit(67) )
		currentCount = ( getMotorEncoder( leftMotor ) + getMotorEncoder ( rightMotor ) ) / 2;
		wait1Msec( WAIT_CYCLE );

	pauseDriveTrain = true;
	setMotorSpeed( leftMotor, 0 );
	setMotorSpeed( rightMotor, 0 );

	drop();
	writeDebugStreamLine( "%f: %d, %f, %f, %f", time1[T1], robotSpeed, Ki, Kp, currentCount );


/*
	int targetCount = cmToEncoderUnit(distance);
	goStraightDecel(90, 0.002, 0.5, 23);
	//wait(5);
	//pickup();
	//setMotorTarget( armMotor, iArmLv[2], 100 );
	wait1Msec( abs( iArmLv[2] - getMotorEncoder( armMotor ) ) * MS_PER_ENCODER_COUNT );
	//wait(0.5);
	setMotorSpeed( armMotor, 0 );
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorBrakeMode(leftMotor, motorHold);
	setMotorBrakeMode(rightMotor, motorHold);
	goStraightDecel(90, 0.003, 0.6, 43);
	drop();

	repeat (forever)
		wait(1);
*/
}
