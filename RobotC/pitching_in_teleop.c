#pragma config(Sensor, port5,  LED,            sensorVexIQ_LED)
#pragma config(Sensor, port8,  gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port9,  sonar,          sensorVexIQ_Distance)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          intakeMotor,   tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor4,          catapultMotor, tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor11,         gateMotor,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float dt = 25;
float allowed_time = 7.5;
float iChC_filtered = 0.0;
float iChA_filtered = 0.0;
float desired_heading = 0.0;

#define GYRO_SAMPLING_SECONDS 5
#define ACCEPTABLE_DRIFT_RANGE 0.05

#define COUNT_PER_ROUND 960
#define WHEEL_TRAVEL 20
#define GEAR_RATIO 2
#define RATE 1

#define SONAR_IN_RANGE 90

int intakeSpeed = 80;

int iStrafeMapping[101] = {
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,
	20,20,20,20,20,20,20,20,20,20,
	20,20,20,20,20,20,20,20,20,20,
	30,30,30,30,30,30,30,30,30,30,
	30,30,30,30,30,30,30,30,30,30,
	40,40,40,40,40,60,60,60,60,60,
	60,60,60,80,80,95,95,95,95,95,95}; // Max not to 100 to allow room for PID.

int iTurnMapping[101] = {
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,
	20,20,20,20,20,20,20,20,20,20,
	20,20,20,20,20,20,20,20,20,20,
	30,30,30,30,30,30,30,30,30,30,
	30,30,30,30,30,30,30,30,30,30,
	30,30,30,30,30,30,30,30,30,30,
	40,40,40,40,40,40,40,60,60,60,60};
/*
float cmToEncoderUnit(float distance)
{
return distance * COUNT_PER_ROUND / WHEEL_TRAVEL / GEAR_RATIO / RATE;
}

//47 to 56 creates a new type of struct and names it structPID
typedef struct {
float setpoint;
float measured_value;
float integral;
float prev_error;
float kp;
float ki;
float kd;
float delta;
}structPID;

structPID pidDrive
structPID pidOrientation




void setGyroStable()
{
fGyroDriftRate = 100;

while (fGyroDriftRate > ACCEPTABLE_DRIFT_RANGE)
{
// Let the LED flashing to remind people do not move the robot.
setTouchLEDColor(LED,colorRed);
//setTouchLEDBlinkTime(LED, 14,6);
//wait1Msec(3000);
setTouchLEDBlinkTime(LED, 0,1);
wait1Msec(2000);

setTouchLEDColor(LED,colorGreen);
setTouchLEDBlinkTime(LED, 8, 12);

resetGyro(gyro);
clearTimer(T4);
wait1Msec(GYRO_SAMPLING_SECONDS*1000);

fGyroDriftRate = getGyroDegreesFloat(gyro) / GYRO_SAMPLING_SECONDS;

if (fGyroDriftRate < ACCEPTABLE_DRIFT_RANGE)
setTouchLEDColor(LED, colorGreen);
else
setTouchLEDColor(LED, colorRed);

setTouchLEDBlinkTime(LED, 4, 4);
wait1Msec(1);
setTouchLEDColor(LED,colorNone);
setTouchLEDBlinkTime(LED, 1, 0);
}

}

float getGyroStable()
{
return getGyroDegreesFloat(gyro) - fGyroDriftRate * time1[T4] / 1000;
}

void resetGyroStable()
{
resetGyro(gyro);
clearTimer(T4);
}



float PIDControl (structPID &pid)
{
float error = pid.setpoint - pid.measured_value;

if ( abs(error) < pid.delta )
error = 0;

pid.integral = pid.integral + error * dt;
float derivative = ( error - pid.prev_error ) / dt;
float output = pid.kp * error + pid.ki * pid.integral + pid.kd * derivative;
pid.prev_error = error;

return output;
}

void strafePID(int distance, int maxJoyStick, float Kp, float Ki, float Kd, int delta)
{
int tmpJoyStick, motor_a, motor_b, ChA_selector, ChB_selector;

pidDrive.setpoint = cmToEncoderUnit(distance);
pidDrive.measured_value = 0;
pidDrive.kp = Kp;
pidDrive.ki = Ki;
pidDrive.kd = Kd;
pidDrive.delta = cmToEncoderUnit(delta);
pidDrive.integral = 0;
pidDrive.prev_error = 0;

resetMotorEncoder(leftMotor);
resetMotorEncoder(rightMotor);

motor_a = leftMotor;
motor_b = rightMotor;
ChA_selector = 1;
//ChB_selector = 0;

while ( abs(pidDrive.setpoint - pidDrive.measured_value) > pidDrive.delta )
{
pidDrive.measured_value = sgn(pidDrive.setpoint) * (abs(getMotorEncoder(motor_a)) + abs(getMotorEncoder(motor_b))) / 2;

tmpJoyStick = PIDControl(pidDrive);
if (abs(tmpJoyStick) > maxJoyStick)
tmpJoyStick = maxJoyStick * sgn(tmpJoyStick);

iChA_filtered = tmpJoyStick * ChA_selector;

//writeDebugStreamLine( "%f %f %f %f %f %f %f %f", getTimerValue(T2), iChA_filtered, iChC_filtered, getGyroDegrees(gyro), getGyroStable(), desired_heading, pidDrive.setpoint, pidDrive.measured_value );
//writeDebugStreamLine( "%f %f %f %f %f %f %f %f %f", getTimerValue(T2), iChA_filtered, abs(getMotorEncoder(FL))-pre_FL, abs(getMotorEncoder(FR))-pre_FR, abs(getMotorEncoder(BL))-pre_BL, abs(getMotorEncoder(BR))-pre_BR, abs(getMotorEncoder(FL))+abs(getMotorEncoder(FR)), abs(getMotorEncoder(BL))+abs(getMotorEncoder(BR)), pidLight.measured_value );

wait1Msec(dt);
}
iChA_filtered = 0;
}

void turnTo(float heading, float delta)
{
float tempDelta = pidOrientation.delta;
pidOrientation.delta = delta;
pidOrientation.integral = 0;
pidOrientation.prev_error = 0;

desired_heading = heading;
waitUntil( abs(getGyroStable() - desired_heading) <= pidOrientation.delta );
pidOrientation.delta = tempDelta;
}
*/
task drive()
{
	while (true)
	{
		iChA_filtered=iStrafeMapping[abs(getJoystickValue(ChA))]*sgn(getJoystickValue(ChA));
		iChC_filtered=iTurnMapping[abs(getJoystickValue(ChC))]*sgn(getJoystickValue(ChC));

		//		writeDebugStreamLine( "%f %f %f %f %f %f %f %f", getTimerValue(T2), iChA_filtered, iChC_filtered, getGyroDegrees(gyro), getGyroStable(), desired_heading );
		setMotorSpeed(leftMotor,(iChA_filtered+iChC_filtered)/1);
		setMotorSpeed(rightMotor,(iChA_filtered-iChC_filtered)/1);
		wait1Msec(dt);
	}
}

void set_catapult()
{
	while (getDistanceValue(sonar) > SONAR_IN_RANGE)
	{
		setMotorSpeed(catapultMotor, -100);
		wait1Msec(dt);
	}
	setMotorSpeed(catapultMotor, 0);
}

void fire_catapult()
{
	if (getDistanceValue(sonar) < SONAR_IN_RANGE)
	{
		setTouchLEDRGB(LED, 255, 0, 0);
		setMotorSpeed(gateMotor, 100);
		wait1Msec(300);
		setMotorSpeed(gateMotor, 0);

		setMotorSpeed(catapultMotor, -100);
		wait1Msec(500);
		setMotorTarget(gateMotor, -500, 100);
		wait1Msec(800);
	}
	setTouchLEDRGB(LED, 0, 255, 0);
	set_catapult();
}

void initialize()
{
	setMotorEncoderUnits(encoderCounts);

	setMotorBrakeMode(rightMotor, motorCoast);
	setMotorBrakeMode(leftMotor, motorCoast);

	setMotorSpeed(gateMotor, 100);
	wait1Msec(800);
	resetMotorEncoder(gateMotor);
	setMotorSpeed(gateMotor, 0);

	setMotorTarget(gateMotor, -500, 100);
	set_catapult();

	setTouchLEDColor(LED,colorGreen);
	//waitUntil(getTouchLEDValue(LED));

	setMotorBrakeMode(rightMotor, motorHold);
	setMotorBrakeMode(leftMotor, motorHold);
	setMotorBrakeMode(gateMotor, motorHold);
}


//115 gate up
bool catapultReady = false;
task catapult()
{
	float timeStamp;

	while(true)
	{
		setMotorTarget(gateMotor, -500, 100);
		if(getJoystickValue(BtnRUp))
		{
			fire_catapult();
		/*
			setTouchLEDRGB(LED, 255, 255, 255);
			setMotorSpeed(catapultMotor, -100);
			wait1Msec(500);
			timeStamp = time1[T1];
		}
		else if(getDistanceValue(sonar)< SONAR_IN_RANGE && time1[T1] - timeStamp > 500)
		{
			displayTextLine(3, "%f", getDistanceValue(sonar));
			setTouchLEDRGB(LED, 255, 0, 255);
			setMotorSpeed(catapultMotor, 0);
		*/
		}
		writeDebugStreamLine( "%f %f %f %f", getTimerValue(T1), timeStamp, getDistanceValue(sonar), getMotorSpeed(catapultMotor) );
		wait1Msec(dt);
	}
}

task main()
{
	initialize();
	startTask(catapult);
	//	setGyroStable();
	//setTouchLEDColor(LED,colorBlue);
	//waitUntil(getTouchLEDValue(LED));

	//setTouchLEDColor(LED,colorGreen);
	clearDebugStream();
	/*
	resetGyroStable();
	desired_heading = 0;
	resetTimer(T2);

	pidOrientation.delta = 5;
	pidOrientation.kp = 0.75;
	pidOrientation.ki = 0;
	pidOrientation.kd = 1.1;
	*/
	startTask(drive);

	while(true)
	{

		/*
		if(getJoystickValue(BtnLUp)==1 && time1[T1] >= 400)
		{
		if(intakeOn == true)
		{
		setMotorSpeed(intakeMotor, intakeSpeed);
		}
		else
		{
		setMotorSpeed(intakeMotor, 0);
		}
		resetTimer(T1);
		intakeOn = (-1)*intakeOn+1;
		}
		*/
		if(getJoystickValue(BtnLUp))
		{
			setMotorSpeed(intakeMotor, intakeSpeed);
		}
		else if(getJoystickValue(BtnLDown))
		{
			setMotorSpeed(intakeMotor, -intakeSpeed);
		}/*
		else if (intakeOn)
		{
		setMotorSpeed(intakeMotor, intakeSpeed);
		}*/
		else
		{
			setMotorSpeed(intakeMotor, 0);
		}

		if(getJoystickValue(BtnFUp) && time1[T3] >= 400)
		{
			if(intakeSpeed == 50)
			{
				intakeSpeed = 100;
			}
			else
			{
				intakeSpeed = 50;
			}
			resetTimer(T3);
		}
		/*
		if(getJoystickValue(BtnEUp))
		{
			setMotorSpeed(gateMotor, -100);
		}
		else if(getJoystickValue(BtnEDown))
		{
			setMotorSpeed(gateMotor, 100);
		}
		else if(!getJoystickValue(BtnEUp) || !getJoystickValue(BtnEDown))
		{
			setMotorSpeed(gateMotor, 0);
		}*/
		wait1Msec(dt);

	}
}
