#pragma config(Sensor, port8,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor7,          rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RATE 1.05
#define WAIT_CYCLE 20
#define MIN_SPEED 30
#define COUNT_PER_ROUND 960
#define GEAR_RATIO 2
#define DECEL_RATE 0.75
#define WHEEL_TRAVEL 20.0

#define ON_SPOT_TURN 0
#define LEFT_WHEEL_TURN 1
#define RIGHT_WHEEL_TURN 2
#define TWO_WHEEL_TURN 3

#define ARM_SPEED 100
#define TAIL_SPEED 60
#define CLAW_SPEED 100

#define CLAW_OPEN -120
#define CLAW_CLOSE -450
#define CLAW_DELTA 65

#define TAIL_UP 2000
#define TAIL_DOWN 960
#define TAIL_DELTA 65

#define ARM_DELTA 65
#define MS_PER_ENCODER_UNIT 1
#define MS_PER_DEGREE_ROBOT_TURN 12


int currentCount, pickUpTrigger, targetHeading, cubeLevel;
int iArmLv[4] = {105, 400, 1100, 1455};

int tailTarget;
float timeStamp;

void reset_gyro_timer_encoder()
// Prepare robot
{
	wait(1);
	resetGyro(Gyro);

	clearTimer(T1);

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorBrakeMode(leftMotor, motorHold);
	setMotorBrakeMode(rightMotor, motorHold);

	targetHeading = 0;

}

float cmToEncoderUnit(float distance)
{
	return distance * COUNT_PER_ROUND / WHEEL_TRAVEL / GEAR_RATIO / RATE;
}

void goStraightDecel(int distance, int maxSpeed, float Ki, float Kp, int slowZonePercent)
//For no load: Ki = 0.0026, Kp = 0.5
{
	float motorSpeed;
	float error = 0, integral = 0, output;
	int targetCount = cmToEncoderUnit(distance);
	float slowZone = targetCount * slowZonePercent / 100;

	writeDebugStreamLine("targetCount = %d", targetCount);
	writeDebugStreamLine("slowZone = %d", slowZone);

	currentCount = 0;
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	clearTimer( T2 );

	while ( currentCount < targetCount && time1[T2] < ( targetCount * MS_PER_ENCODER_UNIT * 100 / MIN_SPEED ) )//second requirement is multiplying the time taken to get to targetCount at speed 100 with the ratio of speed 100 to MIN_SPEED (100/MIN_SPEED), because MS_PER_ENCODER was recorded at speed 100
	{
		error = getGyroDegreesFloat(Gyro) - targetHeading;
		integral = integral + error;
		output = error * Kp + integral * Ki;
//idk
    if ( currentCount < ( targetCount - slowZone ) )
		{
			motorSpeed = maxSpeed;
		}
		else
		{
			motorSpeed = sgn(maxSpeed) * MIN_SPEED + DECEL_RATE * ( maxSpeed - sgn(maxSpeed) * MIN_SPEED ) * ( targetCount - currentCount ) / slowZone;
		}

		setMotorSpeed(leftMotor, motorSpeed + output);
		setMotorSpeed(rightMotor, motorSpeed - output);

		currentCount = abs( getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor) ) / 2;
		displayCenteredBigTextLine(3, "%d, %d", getGyroDegrees(Gyro), targetHeading);
		wait1Msec(WAIT_CYCLE);
	}
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 0);
}


void turnDecel( int inputHeading, int turnStyle, float Ki, float Kp, int baseSpeed, int delta )
{
	float error = 0, integral = 0, output;
	int degreeTurning = abs( getGyroDegrees( Gyro ) - inputHeading );

	targetHeading = inputHeading;
	clearTimer( T3 );

	while ( abs( getGyroDegreesFloat(Gyro) - targetHeading ) > delta && time1[T3] < ( degreeTurning * MS_PER_DEGREE_ROBOT_TURN * 100 / MIN_SPEED ) )
	{
		error = getGyroDegreesFloat(Gyro) - targetHeading;
		integral = integral + error;
		output = error * Kp + integral * Ki;

		switch ( turnStyle )
		{
			case ON_SPOT_TURN:
				setMotorSpeed(leftMotor, sgn(error) * baseSpeed + output);
				setMotorSpeed(rightMotor, -sgn(error) * baseSpeed - output);
				break;
			case LEFT_WHEEL_TURN:
				setMotorSpeed(leftMotor, sgn(error) * baseSpeed + output);
				setMotorSpeed(rightMotor, 0);
				break;
			case RIGHT_WHEEL_TURN:
				setMotorSpeed(leftMotor, 0);
				setMotorSpeed(rightMotor, -sgn(error) * baseSpeed - output);
				break;
			case TWO_WHEEL_TURN:
				setMotorSpeed(leftMotor, baseSpeed + output);
				setMotorSpeed(rightMotor, baseSpeed - output);
				break;
		}

		//writeDebugStreamLine("%d:  %d,  %d,  %d", time1[T1], error, integral, output);
		wait1Msec(WAIT_CYCLE);
	}
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 0);
}

/*
void LEDBusiness(int colour, int blinkTimeOn, int blinkTimeOff, int blinkColour, int blink)
{

	timeStamp = time1[T1];
	displayCenteredTextLine( 3, "%f", timeStamp );

	if (blink == 0)
	{
		setTouchLEDColor(LED, colour);
		waitUntil( getTouchLEDValue(LED) == 1 );
	}
	else if (blink ==1)
	{
		setTouchLEDColor(LED,colour);
		waitUntil(getTouchLEDValue(LED) == 1);
		setTouchLEDColor(LED,blinkColour);
		setTouchLEDBlinkTime(LED, blinkTimeOn, blinkTimeOff);
	}

	wait(0.3);
	resetGyro(Gyro);
	targetHeading = 0;
}*/


task main()
{
	resetGyro(Gyro);
	setMotorEncoderUnits( encoderCounts );

	goStraightDecel(40, 100, 0.0026, 0.5, 10);
}
