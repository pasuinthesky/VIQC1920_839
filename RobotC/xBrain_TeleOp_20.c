#pragma config(Sensor, port10, LED,            sensorVexIQ_LED)
#pragma config(Sensor, port12, gyro,           sensorVexIQ_Gyro)
#pragma config(Motor,  motor1,          BR,            tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor4,          liftMotorL,    tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          BL,            tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          FL,            tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor7,          FR,            tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         liftMotorR,    tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int error
float setpoint = 0;
float integral = 0;
float dt = 25;
float prev_error = 0;
float allowed_time = 7.5;
float output
float delta = 10
int artificial_ChC_Reading = 0;
#define ARM_DELTA 10
#define MS_PER_ENCODER_UNIT 1

#define LIFT_LEVELS 2
int iLiftLevel[LIFT_LEVELS] = {15, 570};

int iDriveMapping[101] = {
0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,
10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,
20,20,20,20,20,20,20,20,20,20,
30,30,30,30,30,30,30,30,30,30,
40,40,40,40,40,40,40,40,40,40,
50,50,50,50,50,50,50,50,50,50,
60,62,64,66,68,70,72,74,76,78,
84,88,92,96,100,100,100,100,100,100,100};


int iStrafeMapping[101] = {
0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,
10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,
20,20,20,20,20,20,20,20,20,20,
25,25,25,25,25,25,25,25,25,25,
30,30,30,30,30,30,30,40,40,40,
50,50,50,50,50,60,60,60,60,60,
80,80,80,80,80,80,80,80,80,80,
100,100,100,100,100,100,100,100,100,100,100};

int iTurnMapping[101] = {
0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,
20,20,20,20,20,20,20,20,20,20,
20,20,20,20,20,20,20,20,20,20,
25,25,25,25,25,25,25,25,25,25,
30,30,30,30,30,30,30,30,30,30,
30,30,30,30,30,30,30,30,30,30,
30,30,30,30,30,30,30,30,30,30,
40,40,40,40,40,40,40,40,40,40,
50,50,50,50,50,90,90,90,90,90,90};



float PIDControl (float Kp, float Ki, float Kd, float delta)
{
	float measured_value = getGyroHeadingFloat(gyro);
	error = setpoint - measured_value;
	integral = integral + error * dt;
	float derivative = ( error - prev_error ) / dt;
	output = Kp * error + Ki * integral + Kd * derivative;

	prev_error = error;

	return output;
}

void lift_preset()
{
	if (getJoystickValue(BtnRUp)== 1)
	{
		setMotorSpeed(BL, 0 );
		setMotorSpeed(BR, 0 );
		setMotorSpeed(FL, 0 );
		setMotorSpeed(FR, 0 );

		for (int i=0;i<LIFT_LEVELS-1;i=i+1)
		{
			if ( getMotorEncoder(liftMotorL) < ( iLiftLevel[i+1] - ARM_DELTA ) )
			{
				setMotorTarget(liftMotorL,iLiftLevel[i+1],100);
				setMotorTarget(liftMotorR, iLiftLevel[i+1], 100);
				wait1Msec( ( iLiftLevel[i+1] - iLiftLevel[i] ) * MS_PER_ENCODER_UNIT );
				break;
			}
		}
	}
	else if (getJoystickValue(BtnRDown)==1)
	{
		for (int i=LIFT_LEVELS-1;i>0;i=i-1)
		{
			if ( getMotorEncoder(liftMotorL) > ( iLiftLevel[i-1] + ARM_DELTA ) )
			{
				setMotorTarget(liftMotorL,400,100);
				setMotorTarget(liftMotorR, 400,100);
				setMotorSpeed(BL, -50 );
				setMotorSpeed(BR, 50 );
				setMotorSpeed(FL, -50 );
				setMotorSpeed(FR, 50 );
				wait1Msec(500);
				setMotorSpeed(BL, 0 );
				setMotorSpeed(BR, 0 );
				setMotorSpeed(FL, 0 );
				setMotorSpeed(FR, 0 );
				setMotorTarget(liftMotorL,iLiftLevel[i-1],100);
				setMotorTarget(liftMotorR, iLiftLevel[i-1],100);
				wait1Msec( ( iLiftLevel[i] - iLiftLevel[i-1] ) * MS_PER_ENCODER_UNIT );
				break;
			}
		}
	}
}

/*task flashLED()
{
	while( true )
	{
		setTouchLEDRGB(LED, 0, 255, 0);
		sleep( 500 );
		setTouchLEDRGB(LED, 0, 255, 255);
		sleep( 500 );
	}
}*/
task flashLED ()
{
	while (true)
	{
		setTouchLEDColor(LED, colorRed);
		wait1Msec(10);
		setTouchLEDColor(LED, colorBlue);
		wait1Msec(10);
		setTouchLEDColor(LED, colorYellow);
		wait1Msec(10);
		setTouchLEDColor(LED, colorOrange);
		wait1Msec(10);
		setTouchLEDColor(LED, colorGreen);
		wait1Msec(10);
		setTouchLEDColor(LED, colorViolet);
	}
}




task main()
{
	int iChC_filtered;
	int iChA_filtered;
	int iChB_filtered;
	setMotorBrakeMode(FL, motorHold);
	setMotorBrakeMode(FR, motorHold);
	setMotorBrakeMode(BR, motorHold);
	setMotorBrakeMode(BL, motorHold);
	setMotorBrakeMode( liftMotorL, motorHold );
	setMotorBrakeMode( liftMotorR, motorHold )
	setMotorSpeed(liftMotorL, -100);
	setMotorSpeed(liftMotorR, -100);
	wait1Msec(1000);
	setMotorSpeed(liftMotorL, 0);
	setMotorSpeed(liftMotorR, 0) ;

	startTask( flashLED );
	resetMotorEncoder(liftMotorL);
	resetMotorEncoder(liftMotorR);

	while(true)
	{
//		setpoint = 0; //later, we will plug in ChC reading.
//		PIDControl(setpoint, 0.5, 0, 0.1, 0.1);


		iChA_filtered = iDriveMapping[abs(getJoystickValue(ChA))]*sgn(getJoystickValue(ChA));
		iChB_filtered = iStrafeMapping[abs(getJoystickValue(ChB))]*sgn(getJoystickValue(ChB));
		if ( abs(getJoystickValue(ChC)) <= 15 )
		{
			iChC_filtered = output;
		}
		else

//		iChC_filtered = iTurnMapping[abs(getJoystickValue(ChC))]*sgn(getJoystickValue(ChC));

		if ( abs( getJoystickValue (ChC)) > 15 )
		{
			iChC_filtered = iTurnMapping[abs(getJoystickValue(ChC))]*sgn(getJoystickValue(ChC));
		}
		else
		{
			iChC_filtered = PIDControl( 5.4, 1, 5, 5 );
			if ( error <= delta || time1[T1] > allowed_time )
			{
				break;
			}
		}
		lift_preset();

		setMotorSpeed(BL, 0 + iChA_filtered - iChB_filtered - iChC_filtered );
		setMotorSpeed(BR, 0 - iChA_filtered - iChB_filtered - iChC_filtered );
		setMotorSpeed(FL, 0 + iChA_filtered + iChB_filtered - iChC_filtered );
		setMotorSpeed(FR, 0 - iChA_filtered + iChB_filtered - iChC_filtered );
		wait1Msec(dt);
	}
}
